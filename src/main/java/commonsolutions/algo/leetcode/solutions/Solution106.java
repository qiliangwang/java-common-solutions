package commonsolutions.algo.leetcode.solutions;

import commonsolutions.algo.leetcode.base.TreeNode;

/**
 * @author Vader Wang
 */
public class Solution106 {

    /**
     * Given inorder and postorder traversal of a tree, construct the binary tree.
     *
     * Note:
     * You may assume that duplicates do not exist in the tree.
     *
     * For example, given
     *
     * inorder = [9,3,15,20,7]
     * postorder = [9,15,7,20,3]
     * Return the following binary tree:
     *
     *     3
     *    / \
     *   9  20
     *     /  \
     *    15   7
     *            root, left, right
     * preorder  [ 3,     9,  20, 15, 7]
     *           left, root,    right
     * inorder   [9,     3,  15, 20, 7]
     *            left,   right,    root
     * postorder [ 9,    15, 7, 20,   3]
     * @param inorder
     * @param postorder
     * @return
     */
    int pInorder;
    int pPostorder;

    public TreeNode buildTree(int[] inorder, int[] postorder) {
        pInorder = inorder.length - 1;
        pPostorder = postorder.length - 1;
        return helper(inorder, postorder, null);
    }

    public TreeNode helper(int[] inorder, int[] postorder, TreeNode end) {
        if (pPostorder < 0) {
            return null;
        }
        TreeNode root = new TreeNode(postorder[pPostorder--]);

        if (inorder[pInorder] != root.val) {
            root.right = helper(inorder, postorder, root);
        }
        pInorder--;
        if ((end == null) || (inorder[pInorder] != end.val)) {
            root.left = helper(inorder, postorder, end);
        }
        return root;
    }

    public static void main(String[] args) {
        int[] postorder  = {9, 15, 7, 20, 3};
        int[] inorder = {9, 3, 15, 20, 7};
        TreeNode result = new Solution106().buildTree(inorder, postorder);
        System.out.println(result);
    }
}
